{
  "name": "bauer-factory",
  "version": "1.0.3",
  "description": "General utilities for nodejs",
  "keywords": [
    "class",
    "method",
    "type",
    "extend",
    "clone",
    "signature",
    "function",
    "object",
    "create"
  ],
  "license": "MIT",
  "homepage": "https://github.com/yneves/node-bauer-factory",
  "author": {
    "name": "Yuri Neves Silveira",
    "email": "npm@yneves.com",
    "url": "http://yneves.com/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/yneves/node-bauer-factory.git"
  },
  "scripts": {
    "test": "mocha"
  },
  "devDependencies": {
    "q": ">1.0.0",
    "mocha": ">1.0.0"
  },
  "main": "factory.js",
  "readme": "node-bauer-factory\r\n================\r\n\r\n## Installation\r\n\r\n```\r\nnpm install bauer-factory\r\n```\r\n\r\n## Usage\r\n\r\n```js\r\nvar factory = require(\"bauer-factory\");\r\n```\r\n\r\n## .type\r\n\r\nReturned value can be string, number, boolean, date, regexp, error, array, object, arguments, undefined, function or promise. Beware that null is considered to be undefined despite it is an object.\r\n\r\n```js\r\n// returns type of given argument\r\nvar type = factory.type(arg);\r\n```\r\n\r\n## .isNull\r\n\r\n```js\r\nfactory.isNull(arg)\r\n// same as\r\nfactory.type(arg) == \"undefined\"\r\n```\r\n\r\n## .isDate\r\n\r\n```js\r\nfactory.isDate(arg) \r\n// same as\r\nfactory.type(arg) == \"date\"\r\n```\r\n\r\n## .isError\r\n\r\n```js\r\nfactory.isError(arg) \r\n// same as\r\nfactory.type(arg) == \"error\"\r\n```\r\n\r\n## .isBoolean\r\n\r\n```js\r\nfactory.isBoolean(arg) \r\n// same as\r\nfactory.type(arg) == \"boolean\"\r\n```\r\n\r\n## .isArray\r\n\r\n```js\r\nfactory.isArray(arg) \r\n// same as\r\nfactory.type(arg) == \"array\"\r\n```\r\n\r\n## .isNumber\r\n\r\n```js\r\nfactory.isNumber(arg) \r\n// same as\r\nfactory.type(arg) == \"number\"\r\n```\r\n\r\n## .isString\r\n\r\n```js\r\nfactory.isString(arg) \r\n// same as\r\nfactory.type(arg) == \"string\"\r\n```\r\n\r\n## .isObject\r\n\r\n```js\r\nfactory.isObject(arg) \r\n// same as\r\nfactory.type(arg) == \"object\"\r\n```\r\n\r\n## .isRegExp\r\n\r\n```js\r\nfactory.isRegExp(arg) \r\n// same as\r\nfactory.type(arg) == \"regexp\"\r\n```\r\n\r\n## .isFunction\r\n\r\n```js\r\nfactory.isFunction(arg) \r\n// same as\r\nfactory.type(arg) == \"function\"\r\n```\r\n\r\n## .isPromise\r\n\r\n```js\r\nfactory.isPromise(arg) \r\n// same as\r\nfactory.type(arg) == \"promise\"\r\n```\r\n\r\n## .isArguments\r\n\r\n```js\r\nfactory.isArguments(arg) \r\n// same as\r\nfactory.type(arg) == \"arguments\"\r\n```\r\n\r\n## .toArray\r\n\r\nCoerces given argument into array.\r\n\r\n```js\r\nfactory.toArray(arg)\r\n// same as\r\nArray.prototype.slice.call(arg)\r\n```\r\n\r\n## .extend\r\n\r\nPerforms a superficial extension on objects or classes.\r\n\r\n```js\r\n// extends the original object and returns it\r\nfactory.extend(original,object0,object1,object2) \r\n```\r\n\r\n```js\r\n// calling with one argument extends factory itself\r\n// methods is an object having key as the method name \r\n// value is passed through factory.method\r\nfactory.extend(methods) \r\n```\r\n\r\n```js\r\n// calling with a function as first argument extends its prototype\r\n// methods is an object having key as the method name \r\n// value is passed through factory.method\r\nfactory.extend(class,methods) \r\n```\r\n\r\n## .clone\r\n\r\nReturns an equally deep copy of given argument. Works with arrays and objects, values of any other type are bypassed.  \r\n\r\n```js\r\n// deepEqual && notStrictDeepEqual \r\nfactory.clone(arg) \r\n```\r\n\r\n## .method\r\n\r\nAccepts an object containing types/lengths as keys and values as functions.\r\n\r\n```js\r\nvar func = factory.method({\r\n\t0: function() {}, // executed if called with zero arguments\r\n\ts: function(s) {}, // executed if called with one string\r\n\tsf: function(s) {}, // executed if called with a string and a function\r\n\t_: function() {}, // executed if none of the above is matched\r\n});\r\n```\r\n\r\nLetters are taken as the first character of the argument's type as returned by `factory.type`. Any combination can be used to route the function execution. This takes priority over argument's length routing.\r\n\r\n```js\r\nvar func = factory.method({\r\n\to: function() {}, // executed if called with object\r\n\ta: function(s) {}, // executed if called with array or arguments\r\n\tsffb: function(s,f0,f1,b) {}, // executed if called with a string, two functions and a boolean\r\n});\r\n```\r\n\r\nNumbers are taken as the length of the arguments object. Nested rules are supported.\r\n\r\n```js\r\nvar func = factory.method({\r\n\t5: { // executed if called with five arguments\r\n\t\tsssss: function() {}, // five strings\r\n\t\tassss: function() {}, // one array and four strings\r\n\t}, \r\n\t1: function(arg) {}, // executed if called with one argument\r\n});\r\n```\r\n\r\nUnderscore holds the default code. If no rule is matched and there's no `_` throws an `ReferenceError`.\r\n\r\n```js\r\nvar func = factory.method({\r\n\t_: function() {},\r\n});\r\n```\r\n\r\nStrings can be used as code. They are converted to functions internally with the defined arguments.\r\n\r\n```js\r\nvar func = factory.method({\r\n\ts: \"return this.get(s)\", // the given string can be refered as 's'\r\n\tss: \"return this.both(s0,s1)\", // if it's two strings, just add the index\r\n\tf: \"this.on('ready',f)\", // easy to define aliases\r\n});\r\n```\r\n\r\n## .class\r\n\r\nCreates a class with given methods, constructor and inheritance.\r\n\r\n```js\r\nvar Bauer = factory.class({\r\n\r\n\t// requires 'events' and inherits EventEmitter from it\r\n\t// also accepts functions\r\n\tinherits: \"events.EventEmitter\",\r\n\r\n\t// called when new Bauer() is executed\r\n\t// it can also be routed by factory.method if needed\r\n\tconstructor: function() {\r\n\t},\r\n\r\n\t// methods are created by factory.method\r\n\tkillTerrorists: {\r\n\t},\r\n\t\r\n\ttortureSuspects: {\r\n\t},\r\n\t\r\n\tdoWhateverItsNecessary: function() {},\r\n\r\n});\r\n```\r\n\r\nThe created class can be instantiated and inherited just like any other class.\r\n\r\n```js\r\nvar jack = new Bauer();\r\n\r\njack.killTerrorists();\r\n\r\njack.tortureSuspects();\r\n\r\njack.doWhateverItsNecessary();\r\n```\r\n\r\n## .object\r\n\r\nCreates a class just like .class does and returns an instance of it.\r\n\r\n```js\r\n// accepts same arguments as .class\r\nvar jack = factory.object({\r\n\r\n\t// requires 'events' and inherits EventEmitter from it\r\n\t// also accepts functions\r\n\tinherits: \"events.EventEmitter\",\r\n\r\n\t// called when new Bauer() is executed\r\n\t// it can also be routed by factory.method if needed\r\n\tconstructor: function() {\r\n\t},\r\n\r\n\t// methods are created by factory.method\r\n\tkillTerrorists: {\r\n\t\ts: function() {},\r\n\t\tn: function() {},\r\n\t},\r\n\r\n\ttortureSuspects: {\r\n\t\t1: function() {},\r\n\t\t2: function() {},\r\n\t},\r\n\r\n\tdoWhateverItsNecessary: function() {},\r\n\r\n});\r\n```",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/yneves/node-bauer-factory/issues"
  },
  "_id": "bauer-factory@1.0.3",
  "_from": "bauer-factory@>=1.0.0"
}
